# Kafkaesque Architecture Documentation

NOTE: This was generated by Cursor and Claude.

> An ergonomic interface for producing and consuming Kafka messages in Laravel

**Repository:** [AryeoHQ/kafkaesque](https://github.com/AryeoHQ/kafkaesque)  
**License:** MIT  
**Framework:** Laravel (PHP)

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture Diagram](#architecture-diagram)
3. [Core Concepts](#core-concepts)
4. [Component Deep Dive](#component-deep-dive)
5. [Data Flow](#data-flow)
6. [Contract Interfaces](#contract-interfaces)
7. [Configuration](#configuration)
8. [Integration Points](#integration-points)
9. [Best Practices](#best-practices)

---

## Overview

Kafkaesque is a Laravel package that provides an abstraction layer over Apache Kafka, enabling developers to produce and consume messages with a clean, object-oriented API. The package wraps the [laravel-kafka](https://github.com/mateusjunges/laravel-kafka) library by Mateus Junges and adds support for:

- **Topic-centric architecture** — Topics are first-class citizens with environment-aware naming
- **Schema validation** — Native support for Avro schemas and Schema Registry
- **Separation of concerns** — Clear distinction between Messages, Schemas, Topics, Producers, and Consumers
- **Contract-based design** — Interface-driven architecture enabling flexibility and testability

### Key Design Principles

| Principle | Implementation |
|-----------|----------------|
| **Single Responsibility** | Each component (Topic, Message, Producer, Consumer) has one job |
| **Dependency Inversion** | All major components depend on abstractions (contracts/interfaces) |
| **Environment Awareness** | Topics automatically resolve names based on Laravel environment |
| **Schema-First** | Message bodies are strongly-typed via Schema classes |

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              APPLICATION LAYER                               │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────────┐  │
│  │   Your Laravel  │    │  Artisan        │    │  Event Listeners        │  │
│  │   Controllers   │    │  Commands       │    │  / Jobs                 │  │
│  └────────┬────────┘    └────────┬────────┘    └────────────┬────────────┘  │
└───────────┼──────────────────────┼──────────────────────────┼───────────────┘
            │                      │                          │
            ▼                      ▼                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           KAFKAESQUE PACKAGE                                 │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          MESSAGES LAYER                              │   │
│  │  ┌─────────────────────┐         ┌─────────────────────┐            │   │
│  │  │  KafkaesqueMessage  │◄────────│     Contracts       │            │   │
│  │  │  (Abstract Base)    │         │  ├─ IsProducible    │            │   │
│  │  │                     │         │  └─ IsConsumable    │            │   │
│  │  │  • $body (Schema)   │         └─────────────────────┘            │   │
│  │  │  • $key             │                                            │   │
│  │  │  • $defaultTopics   │                                            │   │
│  │  └─────────────────────┘                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           TOPICS LAYER                               │   │
│  │  ┌─────────────────────┐         ┌─────────────────────┐            │   │
│  │  │   KafkaesqueTopic   │◄────────│     Contracts       │            │   │
│  │  │   (Abstract Base)   │         │  ├─ IsProducible    │            │   │
│  │  │                     │         │  ├─ IsConsumable    │            │   │
│  │  │  • getName()        │         │  └─ HasAvroRegistry │            │   │
│  │  │  • produce()        │         └─────────────────────┘            │   │
│  │  │  • consume()        │                                            │   │
│  │  └──────────┬──────────┘                                            │   │
│  └─────────────┼───────────────────────────────────────────────────────┘   │
│                │                                                            │
│       ┌────────┴────────┐                                                   │
│       ▼                 ▼                                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────────────┐  │
│  │  PRODUCERS   │  │  CONSUMERS   │  │           REGISTRIES             │  │
│  │              │  │              │  │                                  │  │
│  │ Kafkaesque   │  │ Kafkaesque   │  │  ┌──────────────────────────┐   │  │
│  │ Producer     │  │ Consumer     │  │  │    KafkaesqueRegistry    │   │  │
│  │              │  │              │  │  │    (Abstract Base)       │   │  │
│  │ • $producer  │  │ • $consumer  │  │  └────────────┬─────────────┘   │  │
│  │   Builder    │  │   Builder    │  │               │                 │  │
│  │ • produce()  │  │ • consume()  │  │               ▼                 │  │
│  └──────────────┘  └──────────────┘  │  ┌──────────────────────────┐   │  │
│         │                 │          │  │      AvroRegistry        │   │  │
│         │                 │          │  │  • Environment           │   │  │
│         │                 │          │  │  • Deserializer          │   │  │
│         │                 │          │  │  • fetchSchema()         │   │  │
│         │                 │          │  └──────────────────────────┘   │  │
│         │                 │          └──────────────────────────────────┘  │
│         │                 │                          │                      │
└─────────┼─────────────────┼──────────────────────────┼──────────────────────┘
          │                 │                          │
          ▼                 ▼                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         LARAVEL-KAFKA (junges/laravel-kafka)                │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────────┐  │
│  │ ProducerBuilder │    │ ConsumerBuilder │    │   Avro Serializers      │  │
│  └─────────────────┘    └─────────────────┘    └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            APACHE KAFKA CLUSTER                             │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────────────┐  │
│  │     Topics      │    │   Partitions    │    │   Schema Registry       │  │
│  └─────────────────┘    └─────────────────┘    └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Core Concepts

### 1. Topics

**Topics** are the central organizing abstraction in Kafkaesque. A Topic represents a Kafka topic and encapsulates:

- **Environment-aware naming** — Different topic names per environment (local, staging, production)
- **Producer/Consumer bindings** — Topics know their associated producers and consumers
- **Schema Registry integration** — Topics can optionally integrate with Avro Schema Registry

```php
class UserEventsTopic extends KafkaesqueTopic implements IsProducible, IsConsumable
{
    protected function getLocalName(): string       { return 'local.user-events'; }
    protected function getDevelopmentName(): string { return 'dev.user-events'; }
    protected function getStagingName(): string     { return 'staging.user-events'; }
    protected function getProductionName(): string  { return 'user-events'; }
    protected function getTestingName(): string     { return 'test.user-events'; }
}
```

### 2. Messages

**Messages** represent the data being sent to or received from Kafka. They consist of:

- **Body** — A Schema object containing the message payload
- **Key** — Optional partition key for message ordering
- **Default Topics** — Array of topic classes the message should be sent to

```php
class UserRegisteredMessage extends KafkaesqueMessage implements IsProducible
{
    protected array $defaultTopics = [UserEventsTopic::class];
    
    public function __construct(UserRegisteredSchema $body, ?string $key = null)
    {
        parent::__construct($body, $key);
    }
}
```

### 3. Schemas

**Schemas** define the structure of message payloads. They provide:

- **Type safety** — Strongly-typed data transfer objects
- **Validation** — Ensure messages conform to expected structure
- **Avro support** — Optional Avro schema integration

```php
class UserRegisteredSchema extends KafkaesqueSchema implements IsAvroSchema
{
    public function __construct(
        public string $userId,
        public string $email,
        public string $name,
        public Carbon $registeredAt
    ) {}
    
    public static function getAvroSchemaName(): string
    {
        return 'user-registered-value';
    }
}
```

### 4. Producers

**Producers** configure how messages are sent to Kafka. They wrap the underlying `ProducerBuilder` and configure:

- Broker connections
- Authentication (SASL)
- Serialization options

```php
class UserEventsProducer extends KafkaesqueProducer
{
    public function __construct()
    {
        $this->producerBuilder = Kafka::publish()
            ->withBrokers(config('kafka.brokers'))
            ->withSasl(/* credentials */);
    }
}
```

### 5. Consumers

**Consumers** configure how messages are received from Kafka. They wrap the `ConsumerBuilder` and configure:

- Broker connections
- Consumer group IDs
- Message handling

```php
class UserEventsConsumer extends KafkaesqueConsumer
{
    public function __construct()
    {
        $this->consumerBuilder = Kafka::consumer()
            ->withBrokers(config('kafka.brokers'))
            ->withConsumerGroupId(config('kafka.consumer_group_id'));
    }
}
```

### 6. Registries

**Registries** provide schema management, primarily for Avro. They:

- Fetch schemas from Schema Registry
- Configure serializers/deserializers
- Handle schema versioning

---

## Component Deep Dive

### KafkaesqueTopic

The `KafkaesqueTopic` abstract class is the foundation for all topic implementations:

```
KafkaesqueTopic
├── getName(): string              # Returns environment-appropriate topic name
├── getEnvironmentName(): string   # Returns current Laravel environment
├── produce(message): bool         # Sends message to this topic
├── consume(): void                # Starts consuming from this topic
│
├── Abstract Methods (must implement)
│   ├── getLocalName(): string
│   ├── getDevelopmentName(): string
│   ├── getStagingName(): string
│   ├── getProductionName(): string
│   └── getTestingName(): string
│
└── Contract Methods (implement if applicable)
    ├── getProducer(): KafkaesqueProducer    # Required by IsProducible
    ├── getConsumer(): KafkaesqueConsumer    # Required by IsConsumable
    ├── handleMessage(): void                 # Required by IsConsumable
    └── getRegistry(): KafkaesqueRegistry    # Required by HasAvroRegistry
```

**Environment Resolution Flow:**

```
getName() called
    │
    ▼
getEnvironmentName() → returns app()->environment()
    │
    ▼
Match environment to method:
├── 'local'       → getLocalName()
├── 'development' → getDevelopmentName()
├── 'staging'     → getStagingName()
├── 'production'  → getProductionName()
└── 'testing'     → getTestingName()
    │
    ▼
Return appropriate topic name string
```

### KafkaesqueMessage

The `KafkaesqueMessage` abstract class structures all messages:

```
KafkaesqueMessage
├── Properties
│   ├── $body: KafkaesqueSchema    # Message payload
│   ├── $key: ?string              # Partition key
│   └── $defaultTopics: array      # Default target topics
│
├── Methods
│   ├── getBody(): KafkaesqueSchema
│   ├── getKey(): ?string
│   ├── getDefaultTopics(): array
│   └── produce(): void            # Available when implementing IsProducible
│
└── Contracts
    ├── IsProducible               # For outbound messages
    │   └── produce(): void        # Send to default topics
    │
    └── IsConsumable               # For inbound message handlers
        ├── handle(): void         # Process the message
        └── shouldHandle(): bool   # Guard for conditional processing
```

### KafkaesqueProducer

Producers encapsulate message production configuration:

```
KafkaesqueProducer
├── Properties
│   └── $producerBuilder: ProducerBuilder    # From laravel-kafka
│
├── Methods
│   ├── getProducerBuilder(): ProducerBuilder
│   └── produce(topic, message): bool
│
└── Production Flow
    producerBuilder
        ->onTopic(topic->getName())
        ->withMessage(new Message(
            body: message->getBody()->toArray(),
            key: message->getKey()
        ))
        ->send()
```

### AvroRegistry

The Avro Registry provides Schema Registry integration:

```
AvroRegistry extends KafkaesqueRegistry
├── Properties
│   ├── $environment: IsAvroRegistryEnvironment
│   └── $deserializer: AvroDeserializer
│
├── Methods
│   ├── getEnvironment(): IsAvroRegistryEnvironment
│   ├── getDeserializer(): AvroDeserializer
│   ├── fetchSchema(schemaName): array
│   └── getSerializer(): callable
│
└── Environments
    IsAvroRegistryEnvironment
    ├── getBaseUri(): string       # Schema Registry URL
    └── getName(): string          # Environment identifier
```

---

## Data Flow

### Producing Messages

```
1. Application creates Schema
   │
   ▼
2. Application creates Message with Schema
   │
   ▼
3. Message->produce() called OR Topic->produce(message) called
   │
   ▼
4. Topic resolves environment-specific name
   │
   ▼
5. Topic gets Producer instance
   │
   ▼
6. If HasAvroRegistry:
   │  └── Get serializer from Registry
   │
   ▼
7. Producer builds message with laravel-kafka
   │
   ▼
8. Message sent to Kafka cluster
```

**Code Example:**

```php
// 1. Create schema
$schema = new UserRegisteredSchema(
    userId: '12345',
    email: 'user@example.com',
    name: 'John Doe',
    registeredAt: now()
);

// 2. Create message
$message = new UserRegisteredMessage($schema, key: '12345');

// 3a. Produce via message (uses default topics)
$message->produce();

// 3b. OR produce via topic (explicit topic)
(new UserEventsTopic())->produce($message);
```

### Consuming Messages

```
1. Artisan command starts consumer
   │
   ▼
2. Topic->consume() called
   │
   ▼
3. Topic gets Consumer instance
   │
   ▼
4. Consumer connects to Kafka cluster
   │
   ▼
5. Consumer receives message from Kafka
   │
   ▼
6. If HasAvroRegistry:
   │  └── Deserialize with Avro deserializer
   │
   ▼
7. Topic->handleMessage() invoked
   │
   ▼
8. Route to appropriate Message handler
   │
   ▼
9. Message handler->handle() processes data
```

**Code Example:**

```php
// Artisan Command
class ConsumeUserEvents extends Command
{
    protected $signature = 'kafka:consume-user-events';

    public function handle(): void
    {
        (new UserEventsTopic())->consume();
    }
}

// Topic's handleMessage implementation
public function handleMessage(ConsumerMessage $message, MessageConsumer $consumer): void
{
    $body = UserEventSchema::from($message->getBody());
    
    $handler = match ($body->eventType) {
        'user.registered' => new UserRegisteredHandler($body, $message->getKey()),
        'user.updated'    => new UserUpdatedHandler($body, $message->getKey()),
        default           => null,
    };
    
    $handler?->handle();
}
```

---

## Contract Interfaces

Kafkaesque uses a contract-based design pattern. Here are all the interfaces:

### Topic Contracts

| Contract | Purpose | Methods |
|----------|---------|---------|
| `IsProducible` | Topic can produce messages | `getProducer(): KafkaesqueProducer` |
| `IsConsumable` | Topic can consume messages | `getConsumer(): KafkaesqueConsumer`<br>`handleMessage(ConsumerMessage, MessageConsumer): void` |
| `HasAvroRegistry` | Topic uses Avro schemas | `getRegistry(): KafkaesqueRegistry` |

### Message Contracts

| Contract | Purpose | Methods |
|----------|---------|---------|
| `IsProducible` | Message can be produced | `produce(): void` |
| `IsConsumable` | Message can be consumed/handled | `handle(): void`<br>`shouldHandle(): bool` |

### Schema Contracts

| Contract | Purpose | Methods |
|----------|---------|---------|
| `IsAvroSchema` | Schema maps to Avro | `static getAvroSchemaName(): string` |

### Registry Environment Contracts

| Contract | Purpose | Methods |
|----------|---------|---------|
| `IsRegistryEnvironment` | Base environment | — |
| `IsAvroRegistryEnvironment` | Avro-specific environment | `getBaseUri(): string`<br>`getName(): string` |

---

## Configuration

### Package Configuration (`config/kafkaesque.php`)

The package publishes a minimal configuration file. Core Kafka settings typically live in your application's `config/kafka.php`:

```php
// config/kafka.php (application-level)
return [
    'brokers' => env('KAFKA_BROKERS', 'localhost:9092'),
    'username' => env('KAFKA_USERNAME'),
    'password' => env('KAFKA_PASSWORD'),
    'consumer_group_id' => env('KAFKA_CONSUMER_GROUP_ID', 'my-app'),
    'schema_registry_url' => env('KAFKA_SCHEMA_REGISTRY_URL'),
];
```

### Environment Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `KAFKA_BROKERS` | Comma-separated broker list | `broker1:9092,broker2:9092` |
| `KAFKA_USERNAME` | SASL username | `my-user` |
| `KAFKA_PASSWORD` | SASL password | `secret` |
| `KAFKA_CONSUMER_GROUP_ID` | Consumer group identifier | `my-app-consumers` |
| `KAFKA_SCHEMA_REGISTRY_URL` | Avro Schema Registry URL | `https://registry.example.com` |

---

## Integration Points

### Laravel Integration

```
┌─────────────────────────────────────────────────────────────────┐
│                        LARAVEL APPLICATION                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Service Provider                                                │
│  └── KafkaesqueServiceProvider                                   │
│      ├── Publishes config                                        │
│      └── Registers migrations (if any)                           │
│                                                                  │
│  Artisan Commands                                                │
│  └── Custom commands extend Illuminate\Console\Command           │
│      └── Call Topic->consume() for long-running consumers        │
│                                                                  │
│  Jobs & Queues                                                   │
│  └── Message handlers can dispatch Laravel jobs                  │
│      └── Async processing of consumed messages                   │
│                                                                  │
│  Events                                                          │
│  └── Message handlers can dispatch Laravel events                │
│      └── Decouple Kafka messages from application logic          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### External Dependencies

```
┌─────────────────────────────┐
│    junges/laravel-kafka    │  ← Core Kafka PHP client wrapper
├─────────────────────────────┤
│  • ProducerBuilder          │
│  • ConsumerBuilder          │
│  • Message                  │
│  • SASL configuration       │
└─────────────────────────────┘
            │
            ▼
┌─────────────────────────────┐
│        php-rdkafka          │  ← PHP extension for Kafka
└─────────────────────────────┘
            │
            ▼
┌─────────────────────────────┐
│      Apache Kafka           │  ← Message broker
├─────────────────────────────┤
│  • Topics                   │
│  • Partitions               │
│  • Consumer Groups          │
└─────────────────────────────┘
            │
            ▼
┌─────────────────────────────┐
│   Confluent Schema Registry │  ← (Optional) Avro schema storage
└─────────────────────────────┘
```

---

## Best Practices

### 1. Directory Structure

Organize your Kafka components in a dedicated namespace:

```
app/
└── Kafka/
    ├── Consumers/
    │   └── UserEventsConsumer.php
    ├── Messages/
    │   ├── UserRegisteredMessage.php
    │   └── UserUpdatedMessage.php
    ├── Producers/
    │   └── UserEventsProducer.php
    ├── Registries/
    │   └── Environments/
    │       └── ProductionRegistryEnvironment.php
    ├── Schemas/
    │   ├── UserRegisteredSchema.php
    │   └── UserEventSchema.php
    └── Topics/
        └── UserEventsTopic.php
```

### 2. Topic Design

- **One topic per domain event type** — e.g., `user-events`, `order-events`
- **Use environment prefixes** — Prevents cross-environment message pollution
- **Implement both contracts when needed** — Topics can be both producible and consumable

### 3. Message Design

- **Keep messages immutable** — Construct fully in constructor
- **Use descriptive keys** — Keys enable ordered processing within partitions
- **Separate handlers from messages** — `IsConsumable` messages are handlers, not data

### 4. Schema Design

- **Use DTOs** — Schemas should be simple data transfer objects
- **Leverage Spatie's laravel-data** — Great for `from()` and `toArray()` methods
- **Version your schemas** — Use Schema Registry for backwards compatibility

### 5. Consumer Resilience

```php
// In your message handler
public function handle(): void
{
    if (!$this->shouldHandle()) {
        return; // Skip invalid messages
    }
    
    try {
        // Dispatch to queue for reliable processing
        ProcessUserRegistration::dispatch($this->body);
    } catch (Exception $e) {
        // Log and potentially retry or dead-letter
        Log::error('Failed to handle message', [
            'message' => $this->body,
            'error' => $e->getMessage()
        ]);
        throw $e;
    }
}

protected function shouldHandle(): bool
{
    return !is_null($this->body->userId) 
        && !is_null($this->body->email);
}
```

### 6. Testing

```php
class UserRegisteredMessageTest extends TestCase
{
    public function test_message_creation(): void
    {
        $schema = new UserRegisteredSchema(
            userId: '12345',
            email: 'test@example.com',
            name: 'Test User',
            registeredAt: now()
        );

        $message = new UserRegisteredMessage($schema, key: '12345');

        $this->assertEquals('12345', $message->getKey());
        $this->assertEquals('test@example.com', $message->getBody()->email);
    }
    
    public function test_message_has_correct_default_topics(): void
    {
        $message = new UserRegisteredMessage(/* ... */);
        
        $this->assertContains(
            UserEventsTopic::class, 
            $message->getDefaultTopics()
        );
    }
}
```

---

## Summary

Kafkaesque provides a clean, Laravel-idiomatic interface for Apache Kafka messaging. Its architecture centers on:

| Component | Responsibility |
|-----------|----------------|
| **Topics** | Environment-aware Kafka topic abstraction |
| **Messages** | Typed message containers with routing logic |
| **Schemas** | Strongly-typed message payload definitions |
| **Producers** | Message production configuration |
| **Consumers** | Message consumption configuration |
| **Registries** | Schema Registry integration for Avro |

The contract-based design enables flexibility while maintaining type safety, and the environment-aware topic naming simplifies multi-environment deployments.

---

*Documentation generated for [AryeoHQ/kafkaesque](https://github.com/AryeoHQ/kafkaesque) v0.0.3*
